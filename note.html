<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>算法图解 Grokking-algorithms</title>
        <style>
</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-light">
        <h1 id="算法图解-grokking-algorithms">算法图解 Grokking-algorithms</h1>
<h2 id="第一章-简介">第一章 简介</h2>
<h3 id="问题解决技巧">问题解决技巧</h3>
<ul>
<li>游戏相关：使用<strong>图算法</strong>编写跟踪用户的AI系统</li>
<li>使用<strong>K-means</strong>最近邻算法编写推荐系统</li>
<li>设计并解决规定时间内无法完成的问题</li>
</ul>
<h3 id="二分查找">二分查找</h3>
<ul>
<li>仅当数列是有序的时候才可以使用</li>
<li>log的概念</li>
</ul>
<h3 id="大o表示法">大O表示法</h3>
<p>表示了算法有多快</p>
<p>表示了最糟情况下的运算次数</p>
<p><strong>例：</strong></p>
<p>在正方形纸上画16个格子；</p>
<p>简单算法：逐一画      16步    O(N)</p>
<p>二分算法：对折四次    4步     O(logN)</p>
<h3 id="常见的大o运算时间">常见的大O运算时间</h3>
<ul>
<li>O(logN) 对数时间，如二分查找</li>
<li>O(N)    线性时间，如遍历</li>
<li>O(NlogN)快速排序，较快</li>
<li>O(N^2)  选择排序，较慢</li>
<li>O(N!)   旅行商问题，非常慢</li>
</ul>
<p><strong>tips</strong></p>
<p>算法的速度指的是操作数的增速</p>
<p>随着输入的增加，其运行时间将以怎样的速度增加</p>
<h3 id="旅行商问题">旅行商问题</h3>
<p>有一位旅行商要前往5个城市，计算他的最短路线</p>
<p>5个城市的路线有120种情况，6个城市有720种情况</p>
<p>所以该算法的计算次数为N!</p>
<hr>
<h2 id="第二章-选择排序">第二章 选择排序</h2>
<h3 id="数组和链表">数组和链表</h3>
<ul>
<li>形象的链表解释：藏宝图寻宝</li>
<li>链表的缺点：访问最后一个元素时需要逐一遍历前面的元素，效率很低</li>
<li>数组的缺点：需要连续的空间存储数据</li>
<li>元素插入：
<ul>
<li>链表：修改前一个元素的next指针的指向</li>
<li>数组：所有元素后移，且有可能影响内存的存储</li>
</ul>
</li>
<li>元素删除：同上</li>
</ul>
<table>
<thead>
<tr>
<th>O</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取</td>
<td>O(1)</td>
<td>O(N)</td>
</tr>
<tr>
<td>插入</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="选择排序">选择排序</h3>
<p>O(N^2)</p>
<hr>
<h2 id="第三章-递归">第三章 递归</h2>
<p>如果使用循环，程序的性能可能更高；</p>
<p>如果使用递归，程序可能更容易理解。</p>
<p>如何选择要看什么对你来说更重要。</p>
<h3 id="基线条件和递归条件">基线条件和递归条件</h3>
<ul>
<li>
<p>基线条件(base case):
边界，即函数不再调用自己时的条件</p>
</li>
<li>
<p>递归条件(recursive case):
函数调用自己时的条件</p>
</li>
</ul>
<h3 id="调用栈">调用栈</h3>
<p>用于储存函数的多个变量，例如函数内部调用另一个函数的情况</p>
<h3 id="递归调用栈">递归调用栈</h3>
<p>古之欲明明德于天下者，先治其国。</p>
<p>欲治其国者，先齐其家。</p>
<p>欲齐其家者，先修其身。</p>
<p>欲修其身者，先正其心。</p>
<p>欲正其心者，先诚其意。</p>
<p>欲诚其意者，先致其知。</p>
<p>致知在格物。</p>
<p>物格而后知至，</p>
<p>知至而后意诚，</p>
<p>意诚而后心正，</p>
<p>心正而后身修，</p>
<p>身修而后家齐，</p>
<p>家齐而后国治，</p>
<p>国治而后天下平。</p>
<hr>
<h2 id="第四章-快速排序">第四章 快速排序</h2>
<h3 id="分治法-divide-and-conquer">分治法 divide and conquer</h3>
<p>使用D&amp;C解决问题的步骤：</p>
<ol>
<li>找出基线条件，并使他尽可能简单</li>
<li>不断地将问题分解，直到符合基线条件</li>
</ol>
<p><em>欧几里得算法</em></p>
<ul>
<li>二分查找的base case和recursive case
<ul>
<li>base case: <code>f(a, b)</code> 范围内只有两个数</li>
<li>recursive case: 找到中间值，然后递归调用 <code>f(a[begin], a[mid])</code> 和 <code>f(a[mid+1], a[end])</code></li>
</ul>
</li>
</ul>
<h3 id="快速排序-qsort">快速排序 qsort</h3>
<ul>
<li>base case：空数组/一个元素</li>
<li>recursive case：确定基准值，分治为两个数组</li>
</ul>
<h3 id="归纳证明">归纳证明</h3>
<ol>
<li>基线条件</li>
<li>归纳条件</li>
</ol>
<p>举例：我要证明我可以爬到第10层台阶，那么我要先证明我可以爬一层，以此类推</p>
<h3 id="大o表示法的最糟情况和平均情况最快情况">大O表示法的最糟情况和平均情况（最快情况）</h3>
<p>在大O表示法中，O(N)的实际情况是C*N</p>
<p>C是固定常数，是一次算法所需要的时间。</p>
<p>虽然一般不考虑C，但当大O一样时，C就成为了重要参考。</p>
<ul>
<li>
<p>不同的情况取决于调用栈的层数</p>
<p>以qsort为例，如果以第一个数为基准排序一个含有10个元素的有序数组，那么他的调用栈层数为10；但如果以中间数作为基准，那么调用栈层数为5。</p>
<p>所以对于调用栈<strong>最坏情况</strong>为O(N)，<strong>平均情况/最快情况</strong>为O(logN)</p>
<p>又由于每次调用栈内部所要进行的操作为O(N)</p>
<p>那么qsort的最糟情况为O(N^2)，最快情况为O(NlogN)</p>
</li>
</ul>
<hr>
<h2 id="第五章-散列表">第五章 散列表</h2>
<h3 id="散列函数-输入到数字的映射-o1">散列函数 “输入到数字的映射” O(1)</h3>
<ul>
<li>
<p>举例：</p>
<ul>
<li>“姓名” ===&gt; “电话号码”</li>
<li>DNS解析可以使用散列表功能</li>
<li>网站缓存</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>模拟映射关系</li>
<li>防止重复</li>
<li>缓存数据，以免服务器再通过处理来生成他们</li>
</ul>
</li>
<li>
<p>冲突</p>
</li>
</ul>
<p>两个输入分配到的映射相同的情况</p>
<p>解决：在当前存在的映射后建立链表</p>
<ul>
<li>重点</li>
</ul>
<p>散列函数的构建，理想情况是，可以给不同的输入不同的映射</p>
<ul>
<li>效率</li>
</ul>
<p>平均情况下：查找的速度和数组一样快，插入/删除的速度和链表一样</p>
<p>最糟情况下：都是O(N)，很慢</p>
<p>所以避开最糟情况是很重要的，为了避免冲突，需要：</p>
<p><strong>良好的散列函数</strong>和，</p>
<h3 id="填装因子">填装因子</h3>
<p>填装因子 = 散列表包含的元素数量 / 位置总数</p>
<p>填装因子越低，发生冲突的可能性越小。</p>
<p>一般地，如果填装因子 &gt; 0.7，就调整散列表的长度</p>
<hr>
<h2 id="第六章-广度优先搜索">第六章 广度优先搜索</h2>
<h3 id="图">图</h3>
<p>由节点和边组成</p>
<p>有向图和无向图</p>
<p>双向有向图 == 无向图</p>
<ul>
<li>最短路径问题
解决最短路径问题的算法叫做，</li>
</ul>
<h3 id="广度优先搜索">广度优先搜索</h3>
<p>回答两类问题：</p>
<ol>
<li>从节点A出发，有前往节点B的路径吗</li>
<li>从节点A出发，前往B节点的哪条路径最短</li>
</ol>
<ul>
<li>
<p>第一类问题：穷举</p>
</li>
<li>
<p>第二类问题：先检查一度关系，再检查二度关系，以此类推，重点是需要按添加顺序查找，如果顺序混乱，就不能保证所得路径是最短的</p>
</li>
<li>
<p>数据结构：队列queue
先进先出</p>
</li>
<li>
<p>运行时间
O(边数+人数)</p>
</li>
<li>
<p>算法实现</p>
</li>
</ul>
<p>（问）查找朋友网中谁是芒果销售商</p>
<ol>
<li>创建队列</li>
<li>把自己的“朋友”入队</li>
<li>出队，检查他是不是芒果销售商，如果是，返回，如果不是，把他的朋友入队</li>
<li>以此类推，直到队列中没人了，说明没有朋友是芒果销售商</li>
<li>如果有多个结果，检查层级，看哪个芒果销售商和自己关系最好</li>
</ol>
<hr>
<h2 id="第七章-狄克斯特拉算法dijkstras-algorithm">第七章 狄克斯特拉算法（Dijkstra's algorithm）</h2>
<p>适用于有向无环图</p>
<ul>
<li>
<p>找出最快路径</p>
<ol>
<li>找出“最便宜”的节点，即可以在最短时间内到达的节点
<strong>“最便宜”的概念，确保没有到该节点更便宜的路径</strong></li>
<li>更新节点邻居的开销（检查是否有前往他们的更短路径）</li>
<li>循环往复</li>
<li>计算最终路径的时间（总权重最小）</li>
</ol>
</li>
<li>
<p>负权重</p>
</li>
</ul>
<p>如果有负权边就不能使用狄克斯特拉算法</p>
<p>可以使用<strong>贝尔曼-福德算法（Bellman-Ford algorithm）</strong></p>
<p>如何理解？</p>
<p>其实并不是不能解决所有的负权边的问题，比如</p>
<p>a-5-b</p>
<p>a-2-c</p>
<p>c-(-5)-b</p>
<p>第一次遍历所有孩子节点，最便宜的是a-c</p>
<p>接着遍历c的孩子节点，发现c-(-5)-b</p>
<p>那么a-b本来是5就被更新成了最小的-3</p>
<p>这种情况是可以计算出来的</p>
<p>但，如果是从a出发到达的子节点中，b的花费为0</p>
<p>如果权重为正，那多一条路，怎么也不可能比0小</p>
<p>这时Dij的思想，因为遍历完所有子节点的节点就固定在集合里了</p>
<p>这一类特殊的问题是解决不了的</p>
<p>以为这个算法一开始就是基于实际的，不把权重为负的情况考虑进来</p>
<hr>
<h2 id="第八章-贪心算法">第八章 贪心算法</h2>
<h3 id="教室调度问题">教室调度问题</h3>
<p>将尽可能多的课程安排进来</p>
<ol>
<li>选出结束最早的课</li>
<li>选择第一堂课结束后才开始的课</li>
<li>重复直至找到答案</li>
</ol>
<p>贪心算法的优点：每步都采取最优解，简单易行</p>
<p>虽然并非在任何情况下都适用，但易于实现</p>
<h3 id="背包问题">背包问题</h3>
<p>偷东西，三个东西的价值分别是3000(30)，2000(20)，1500(15)，括号内为重量</p>
<p>背包最多可以放35重量的东西</p>
<p>根据贪心算法，结果是偷了3000的东西</p>
<p>但实际的最优解是偷2000+1500</p>
<p>贪心算法有时虽然不能获得最优解，但可以非常接近最优解</p>
<p>有时你只需要找到一个大致能够解决问题的算法，不需要完美的解决问题</p>
<p>这种时候贪心算法是有优势的</p>
<p><strong>练习</strong></p>
<ol>
<li>箱子装车，每个箱子大小不同，要求尽可能地多装</li>
</ol>
<p>每一步都把最大的箱子放入车里
<em>这种算法可以得到最优解</em></p>
<ol start="2">
<li>旅游7天，每个地方的价值不同，需要花费的时间也不同，要求把旅行的价值最大化</li>
</ol>
<p>一般地，价值越高的地方需要花费的时间也会越长
使用贪心算法的话，每一步都要选择价值最高的地方，但忽略了时间
<em>这种算法不一定可以得到最优解</em></p>
<h3 id="集合覆盖问题">集合覆盖问题</h3>
<p>每个广播台都有可以覆盖的省份，要求找出覆盖全国所有省份最小的广播台的集合</p>
<p>算法：</p>
<ol>
<li>列出每个可能的广播台集合O(2^n)</li>
<li>选出最小的可以覆盖全国所有省份的那个广播台集合</li>
</ol>
<p><em>没有任何算法可以快速地解决这个问题</em></p>
<h3 id="近似算法-approximation-algorithm">近似算法 (approximation algorithm)</h3>
<ol>
<li>选出一个覆盖最多省份的广播台</li>
<li>重复，直至覆盖所有省份</li>
</ol>
<p><strong>在获得准确结果需要的时间太长时，可以选择使用近似算法来计算</strong></p>
<p>判断近似算法的标准</p>
<ol>
<li>速度的快慢</li>
<li>得到的近似解和精确解的差距</li>
</ol>
<h3 id="np完全问题">NP完全问题</h3>
<p>第一章的旅行商问题中，要获得最短路径，必须知道每种可能路径的长度</p>
<ul>
<li>两个城市 可能的线路是2条  2！</li>
<li>三个城市 可能的线路是6条  3！</li>
<li>四个城市 可能的线路是24条 4！</li>
</ul>
<p>这个问题与集合覆盖问题的共同之处是：需要计算所有的解才可以知道哪个是最小的，这类问题叫做<strong>NP完全问题</strong></p>
<p>用近似算法解决旅行商问题：</p>
<p>随便选择一个出发城市，每次都把还没去的城市中最近的那个作为目的地</p>
<p>O(N^2)</p>
<h3 id="np完全问题的识别">NP完全问题的识别</h3>
<p>易于解决的问题和NP完全问题的差别通常很小</p>
<ul>
<li>算法的速度会随着元素数量的增加而变的非常慢</li>
<li>涉及“所有组合”的问题</li>
<li>不能对问题进行拆分，必须考虑所有可能出现的情况</li>
<li>涉及到序列且难以解决</li>
<li>涉及到集合并且难以解决</li>
<li>如果可以转换为集合覆盖问题或者旅行商问题</li>
</ul>
<hr>
<h2 id="第九章-动态规划">第九章 动态规划</h2>
<h3 id="背包问题的最优解">背包问题的最优解</h3>
<table>
<thead>
<tr>
<th>物品</th>
<th>speaker</th>
<th>pc</th>
<th>guitar</th>
</tr>
</thead>
<tbody>
<tr>
<td>重量</td>
<td>4</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>价值</td>
<td>3000</td>
<td>2000</td>
<td>1500</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>Guitar</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
</tr>
<tr>
<td>Speaker</td>
<td>1500G</td>
<td>1500G</td>
<td>1500G</td>
<td>3000S</td>
</tr>
<tr>
<td>Laptap</td>
<td>1500G</td>
<td>1500G</td>
<td>2000L</td>
<td>4500LG</td>
</tr>
</tbody>
</table>

    </body>
    </html>