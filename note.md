# 算法图解 Grokking-algorithms

## 第一章 简介

### 问题解决技巧

- 游戏相关：使用**图算法**编写跟踪用户的AI系统
- 使用**K-means**最近邻算法编写推荐系统
- 设计并解决规定时间内无法完成的问题

### 二分查找

- 仅当数列是有序的时候才可以使用
- log的概念

### 大O表示法

表示了算法有多快

表示了最糟情况下的运算次数

**例：**

在正方形纸上画16个格子；

简单算法：逐一画      16步    O(N)

二分算法：对折四次    4步     O(logN)   

### 常见的大O运算时间

- O(logN) 对数时间，如二分查找
- O(N)    线性时间，如遍历
- O(NlogN)快速排序，较快
- O(N^2)  选择排序，较慢
- O(N!)   旅行商问题，非常慢

**tips**

算法的速度指的是操作数的增速

随着输入的增加，其运行时间将以怎样的速度增加

### 旅行商问题

有一位旅行商要前往5个城市，计算他的最短路线

5个城市的路线有120种情况，6个城市有720种情况

所以该算法的计算次数为N!

---

## 第二章 选择排序

### 数组和链表

- 形象的链表解释：藏宝图寻宝
- 链表的缺点：访问最后一个元素时需要逐一遍历前面的元素，效率很低
- 数组的缺点：需要连续的空间存储数据
- 元素插入：
  - 链表：修改前一个元素的next指针的指向
  - 数组：所有元素后移，且有可能影响内存的存储
- 元素删除：同上

| O | 数组 | 链表 |
| ---- | ---- | ---- |
| 读取 | O(1) | O(N) |
| 插入 | O(N) | O(1) |
| 删除 | O(N) | O(1) |

### 选择排序

O(N^2)

---

## 第三章 递归

如果使用循环，程序的性能可能更高；

如果使用递归，程序可能更容易理解。

如何选择要看什么对你来说更重要。

### 基线条件和递归条件

- 基线条件(base case):
  边界，即函数不再调用自己时的条件

- 递归条件(recursive case):
  函数调用自己时的条件

### 调用栈

用于储存函数的多个变量，例如函数内部调用另一个函数的情况

### 递归调用栈

古之欲明明德于天下者，先治其国。

欲治其国者，先齐其家。

欲齐其家者，先修其身。

欲修其身者，先正其心。

欲正其心者，先诚其意。

欲诚其意者，先致其知。

致知在格物。

物格而后知至，

知至而后意诚，

意诚而后心正，

心正而后身修，

身修而后家齐，

家齐而后国治，

国治而后天下平。

---

## 第四章 快速排序

### 分治法 divide and conquer

使用D&C解决问题的步骤：

1. 找出基线条件，并使他尽可能简单
2. 不断地将问题分解，直到符合基线条件

*欧几里得算法*

- 二分查找的base case和recursive case
  - base case: `f(a, b)` 范围内只有两个数
  - recursive case: 找到中间值，然后递归调用 `f(a[begin], a[mid])` 和 `f(a[mid+1], a[end])`

### 快速排序 qsort

- base case：空数组/一个元素
- recursive case：确定基准值，分治为两个数组

### 归纳证明

1. 基线条件
2. 归纳条件

举例：我要证明我可以爬到第10层台阶，那么我要先证明我可以爬一层，以此类推

### 大O表示法的最糟情况和平均情况（最快情况）

在大O表示法中，O(N)的实际情况是C*N

C是固定常数，是一次算法所需要的时间。

虽然一般不考虑C，但当大O一样时，C就成为了重要参考。

- 不同的情况取决于调用栈的层数
  
  以qsort为例，如果以第一个数为基准排序一个含有10个元素的有序数组，那么他的调用栈层数为10；但如果以中间数作为基准，那么调用栈层数为5。

  所以对于调用栈**最坏情况**为O(N)，**平均情况/最快情况**为O(logN)

  又由于每次调用栈内部所要进行的操作为O(N)

  那么qsort的最糟情况为O(N^2)，最快情况为O(NlogN)

---

## 第五章 散列表

### 散列函数 “输入到数字的映射” O(1)

- 举例：
  - “姓名” ===> “电话号码”
  - DNS解析可以使用散列表功能
  - 网站缓存

- 作用
  - 模拟映射关系
  - 防止重复
  - 缓存数据，以免服务器再通过处理来生成他们

- 冲突

两个输入分配到的映射相同的情况

解决：在当前存在的映射后建立链表

- 重点

散列函数的构建，理想情况是，可以给不同的输入不同的映射

- 效率

平均情况下：查找的速度和数组一样快，插入/删除的速度和链表一样

最糟情况下：都是O(N)，很慢

所以避开最糟情况是很重要的，为了避免冲突，需要：

**良好的散列函数**和，

### 填装因子

填装因子 = 散列表包含的元素数量 / 位置总数

填装因子越低，发生冲突的可能性越小。

一般地，如果填装因子 > 0.7，就调整散列表的长度

---

## 第六章 广度优先搜索

### 图

由节点和边组成

有向图和无向图

双向有向图 == 无向图

- 最短路径问题
  解决最短路径问题的算法叫做，
  
### 广度优先搜索

回答两类问题：
1. 从节点A出发，有前往节点B的路径吗
2. 从节点A出发，前往B节点的哪条路径最短

- 第一类问题：穷举
- 第二类问题：先检查一度关系，再检查二度关系，以此类推，重点是需要按添加顺序查找，如果顺序混乱，就不能保证所得路径是最短的

- 数据结构：队列queue
  先进先出

- 运行时间
  O(边数+人数)

- 算法实现

（问）查找朋友网中谁是芒果销售商

1. 创建队列
2. 把自己的“朋友”入队
3. 出队，检查他是不是芒果销售商，如果是，返回，如果不是，把他的朋友入队
4. 以此类推，直到队列中没人了，说明没有朋友是芒果销售商
5. 如果有多个结果，检查层级，看哪个芒果销售商和自己关系最好

---

## 第七章 狄克斯特拉算法（Dijkstra's algorithm）

适用于有向无环图

- 找出最快路径
  1. 找出“最便宜”的节点，即可以在最短时间内到达的节点
     **“最便宜”的概念，确保没有到该节点更便宜的路径**
  2. 更新节点邻居的开销（检查是否有前往他们的更短路径）
  3. 循环往复
  4. 计算最终路径的时间（总权重最小）

- 负权重

如果有负权边就不能使用狄克斯特拉算法

可以使用**贝尔曼-福德算法（Bellman-Ford algorithm）**

如何理解？

其实并不是不能解决所有的负权边的问题，比如

a-5-b

a-2-c

c-(-5)-b

第一次遍历所有孩子节点，最便宜的是a-c

接着遍历c的孩子节点，发现c-(-5)-b

那么a-b本来是5就被更新成了最小的-3

这种情况是可以计算出来的

但，如果是从a出发到达的子节点中，b的花费为0

如果权重为正，那多一条路，怎么也不可能比0小

这时Dij的思想，因为遍历完所有子节点的节点就固定在集合里了

这一类特殊的问题是解决不了的

以为这个算法一开始就是基于实际的，不把权重为负的情况考虑进来

---

## 第八章 贪心算法

### 教室调度问题

将尽可能多的课程安排进来

1. 选出结束最早的课
2. 选择第一堂课结束后才开始的课
3. 重复直至找到答案

贪心算法的优点：每步都采取最优解，简单易行

虽然并非在任何情况下都适用，但易于实现

### 背包问题

偷东西，三个东西的价值分别是3000(30)，2000(20)，1500(15)，括号内为重量

背包最多可以放35重量的东西

根据贪心算法，结果是偷了3000的东西

但实际的最优解是偷2000+1500

贪心算法有时虽然不能获得最优解，但可以非常接近最优解

有时你只需要找到一个大致能够解决问题的算法，不需要完美的解决问题

这种时候贪心算法是有优势的

**练习**

1. 箱子装车，每个箱子大小不同，要求尽可能地多装

  每一步都把最大的箱子放入车里
  *这种算法可以得到最优解*

2. 旅游7天，每个地方的价值不同，需要花费的时间也不同，要求把旅行的价值最大化

  一般地，价值越高的地方需要花费的时间也会越长
  使用贪心算法的话，每一步都要选择价值最高的地方，但忽略了时间
  *这种算法不一定可以得到最优解*

### 集合覆盖问题

每个广播台都有可以覆盖的省份，要求找出覆盖全国所有省份最小的广播台的集合

算法：
1. 列出每个可能的广播台集合O(2^n)
2. 选出最小的可以覆盖全国所有省份的那个广播台集合

*没有任何算法可以快速地解决这个问题*

### 近似算法 (approximation algorithm)

1. 选出一个覆盖最多省份的广播台
2. 重复，直至覆盖所有省份

**在获得准确结果需要的时间太长时，可以选择使用近似算法来计算**

判断近似算法的标准

1. 速度的快慢
2. 得到的近似解和精确解的差距

### NP完全问题

第一章的旅行商问题中，要获得最短路径，必须知道每种可能路径的长度

- 两个城市 可能的线路是2条  2！ 
- 三个城市 可能的线路是6条  3！
- 四个城市 可能的线路是24条 4！

这个问题与集合覆盖问题的共同之处是：需要计算所有的解才可以知道哪个是最小的，这类问题叫做**NP完全问题**

用近似算法解决旅行商问题：

随便选择一个出发城市，每次都把还没去的城市中最近的那个作为目的地

O(N^2)

### NP完全问题的识别

易于解决的问题和NP完全问题的差别通常很小

- 算法的速度会随着元素数量的增加而变的非常慢
- 涉及“所有组合”的问题
- 不能对问题进行拆分，必须考虑所有可能出现的情况
- 涉及到序列且难以解决
- 涉及到集合并且难以解决
- 如果可以转换为集合覆盖问题或者旅行商问题

---

## 第九章 动态规划

### 背包问题的最优解

| 物品 | speaker | pc | guitar |
| ---- | ---- | ---- | ---- |
| 重量 | 4 | 3 | 1 |
| 价值 |3000 | 2000 |1500 |


|  | 1 | 2 | 3 | 4 |
| ---- | ---- | ---- | ---- | ---- |
| Guitar | 1500G | 1500G | 1500G | 1500G |
| Speaker | 1500G | 1500G | 1500G | 3000S |
| Laptap | 1500G | 1500G | 2000L | 4500LG |

- 行列的排列顺序发生变化不会影响结果
- 要以最小的元素作为背包大小的基准，即粒度要更细
- 无法处理将一个元素拆分的情况
- 仅当每个子问题是离散的情况下，才可以使用动态规划

### 最长公共子串

- 动态规划可以在给定约束条件下找到最优解
- 每种动态规划解决方案都涉及到上面的表格
- 每一个单元格都是一个子问题，所以动态规划的关键是如何将问题分成子问题

- 单元格中的值是什么？
- 如何将这个问题划分为子问题？
- 网格的坐标轴是什么？

|  | H | I | S | H |
| ---- | ---- | ---- | ---- | ---- |
| F | 0 | 0 | 0 | 0 |
| I | 0 | 1 | 0 | 0 |
| S | 0 | 0 | 2 | 0 |
| H | 0 | 0 | 0 | 3 |

最终arr[i][i]连续递增的字符串就是最长公共子串

### 最长公共子序列

